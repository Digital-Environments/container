<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel Lantana · big collar leaves (ring florets)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #0C0404; display: grid; place-items: center; }
    canvas { width: 560px; height: 560px; image-rendering: pixelated; image-rendering: crisp-edges; }
  </style>
</head>
<body>
  <canvas id="c" width="512" height="512" aria-label="Pixel Lantana animation"></canvas>
  <script>
    // Pixel Lantana — shorter stem, compact heads, **leaves larger than flowers**.
    // FLORETS replaced with ring-based system from the provided snippet.

    const display = document.getElementById('c');
    const dctx = display.getContext('2d');
    dctx.imageSmoothingEnabled = false;

    // Low‑res painter
    const low = document.createElement('canvas');
    const LOW = 152; // extra detail
    low.width = low.height = LOW;
    const l = low.getContext('2d');

    // Palette tuned to photo + ring colors
    const P = {
      bg0: '#0C0404',
      stemD:'#184F22', stem:'#2E7D32', stemL:'#4CAF50',
      leafD:'#0F3A18', leaf:'#1E6B2A', leafL:'#3FAF4E', vein:'#8BC34A',
      // use throat/white/pinks to stand in for inner→outer ring colors
      throat:'#FFC107', white:'#FFF9F0', whiteD:'#EDE5DC',
      pink:'#F48FB1', pink2:'#EC6BA2', lilac:'#E1A7E8',
      shadow:'#140A0C'
    };

    // Ordered dither (4x4 Bayer)
    const B4=[[0,8,2,10],[12,4,14,6],[3,11,1,9],[15,7,13,5]];

    // Utils -----------------------------------------------------------------
    const rnd=(a,b)=>a+Math.random()*(b-a);
    function px(x,y,c){ l.fillStyle=c; l.fillRect(x|0,y|0,1,1);}    
    function mix(a,b,t){const ah=parseInt(a.slice(1),16),bh=parseInt(b.slice(1),16);const ar=(ah>>16)&255,ag=(ah>>8)&255,ab=ah&255;const br=(bh>>16)&255,bg=(bh>>8)&255,bb=bh&255;const r=ar+(br-ar)*t|0,g=ag+(bg-ag)*t|0,b2=ab+(bb-ab)*t|0;return '#'+((1<<24)+(r<<16)+(g<<8)+b2).toString(16).slice(1);}    
    function ditherShade(base, dark, shade, x, y){const m=B4[y&3][x&3]/15;const t=Math.max(0,Math.min(1, shade+(m-0.5)*0.25));return mix(dark,base,t);}    
    function rot(x,y,cx,cy,a){const s=Math.sin(a),c=Math.cos(a);x-=cx;y-=cy;return [x*c-y*s+cx,x*s+y*c+cy];}

    // Geometry --------------------------------------------------------------
    // Shorter stem: move top downward
    const stemTopY=76, stemBaseY=LOW-12; const stemX0=LOW/2; const stemLen=stemBaseY-stemTopY;

    // Wind (smooth w/ gusts)
    let wind=0, windTarget=0, gustTimer=0; const WMAX=3.6; const ph=rnd(0,Math.PI*2);
    function updateWind(dt,t){
      gustTimer-=dt; if(gustTimer<=0){windTarget=rnd(-WMAX,WMAX)*(Math.random()<0.6?0.6:1); gustTimer=rnd(2.5,6);}    
      const osc=0.9*Math.sin(t*0.7+ph)+0.5*Math.sin(t*1.9+ph*0.7); wind+=(windTarget-wind)*0.06; return wind+0.45*osc;}
    function stemOffsetX(y,t,w){const u=(y-stemTopY)/stemLen; const bend=w*(1-(u*u)); const ripple=0.55*Math.sin(u*7.0 - t*1.6); return bend+ripple;}

    // Heads (two) with very short peduncles --------------------------------
    const heads=[
      {dx:-7, dy:-2, phase:rnd(0,6.28), x:stemX0-4, y:stemTopY-4},
      {dx:+7, dy:-2, phase:rnd(0,6.28), x:stemX0+4, y:stemTopY-4},
    ];

    // === FLORETS (from snippet, adapted for two heads) ====================
    // Ring-based layout with color pairs per ring. We reuse palette entries
    // (throat/white/pinks) instead of center/inner/mid/outer.
    const florets=[]; // {hid,r,ang,sz,colA,colB,ph}
    function addRing(hid, r, count, colA, colB){
      for(let i=0;i<count;i++){
        const ang=(i/count)*Math.PI*2 + rnd(-0.08,0.08);
        florets.push({hid, r:r + rnd(-0.4,0.6), ang, sz:3 + (Math.random()<0.28?1:0), colA, colB, ph:Math.random()*Math.PI*2});
      }
    }
    for(let h=0; h<heads.length; h++){
      addRing(h, 3.0,  7, P.throat, P.white);                 // inner (yellow → white)
      addRing(h, 7.0, 11, P.white,  mix(P.white,P.pink,0.4)); // mid transition
      addRing(h,11.5, 15, P.pink,   P.pink2);                 // outer pink
      addRing(h,16.0, 19, P.pink2,  P.lilac);                 // far outer lilac
    }

    function drawFloret(x, y, size, colA, colB, breathe, t){
      // From snippet: compact 4-lobed diamond with a subtle twist and mixed center
      const a = Math.sin(t*0.6 + breathe)*0.25; // tiny twist
      const s = size; // half-span (3 or 4)
      px(x,y,mix(colA,colB,0.25));
      const petals=[[x,y-s],[x+s,y],[x,y+s],[x-s,y]];
      for(let i=0;i<petals.length;i++){
        let [pxx,pyy]=rot(petals[i][0], petals[i][1], x, y, a);
        const shade=0.82 - (i%2)*0.15; const col=ditherShade(colA,colB,shade,pxx|0,pyy|0);
        px(pxx,pyy,col); if(size>3) px(pxx+(pxx>x?1:-1),pyy,col);
      }
    }

    // Drawing ---------------------------------------------------------------
    function drawLeaf(baseX,baseY,len,halfW,angle){
      for(let t=0;t<=len;t++){
        const u=t/len; const prof=Math.sin(u*Math.PI); const serr=1+0.22*Math.sin(u*7.2*Math.PI); const hw=Math.max(1,Math.round(halfW*prof*serr));
        for(let dx=-hw;dx<=hw;dx++){let [x,y]=rot(baseX+dx,baseY+t,baseX,baseY,angle); const shade=0.62+0.3*(dx>0?0.15:0); const col=ditherShade(P.leaf,P.leafD,shade,x|0,y|0); px(x,y,col);}    
        let [vx,vy]=rot(baseX,baseY+t,baseX,baseY,angle); px(vx,vy,P.vein);
        if(t%6===0 && t>4 && t<len-3){const vlen=5+Math.round(3*Math.sin(u*Math.PI)); for(let s=1;s<=vlen;s++){let [vx1,vy1]=rot(baseX-s,baseY+t+Math.round(s*0.15),baseX,baseY,angle); let [vx2,vy2]=rot(baseX+s,baseY+t+Math.round(s*0.15),baseX,baseY,angle); if((s&1)===0){px(vx1,vy1,P.vein); px(vx2,vy2,P.vein);}}}
      }
    }

    function drawCollarLeaves(hx,hy,wind){
      // Make leaves clearly **larger than the flower heads**
      const len=34, hw=16; // big paired leaves beneath each head
      const tilt=wind*0.05;
      drawLeaf(hx-3, hy+7, len, hw, -0.6+tilt);
      drawLeaf(hx+3, hy+7, len, hw,  0.6+tilt);

      // A thicker ring of small bracts around the head, also upsized
      const n=8;
      for(let i=0;i<n;i++){
        const ang=i/n*Math.PI*2 + 0.15;
        const bx=hx + Math.cos(ang)*3; const by=hy + Math.sin(ang)*3;
        drawLeaf(bx, by, 14, 7, ang);
      }
    }

    function drawStem(t,w){
      // main stem
      for(let y=stemTopY;y<=stemBaseY;y++){
        const x=Math.round(stemX0+stemOffsetX(y,t,w*(y<stemTopY+6?1.1:1)));
        const rel=(y-stemTopY)/stemLen; const shade=0.55+0.35*rel; const col=ditherShade(P.stem,P.stemD,shade,x,y); px(x,y,col);
        if(y%3===0) px(x+1,y,P.stemL);
      }
      // very short peduncles
      for(const sign of[-1,1]){
        for(let t2=0;t2<3;t2++){
          const by=stemTopY+1+t2; const bx=Math.round(stemX0+stemOffsetX(by,t,w)+sign*(1+t2));
          px(bx,by,ditherShade(P.stem,P.stemD,0.65,bx,by));
        }
      }
    }

    // Frame -----------------------------------------------------------------
    let start=performance.now();
    function paintLow(t){
      l.clearRect(0,0,LOW,LOW);
      // ground (static)
      for(let x=0;x<LOW;x++){const y=LOW-9+Math.floor(2*Math.sin(x*0.18)); const c=ditherShade(P.shadow,'#000',0.7,x,y); px(x,y,c);}    
      // wind
      const w=updateWind(1/60,t);

      // stem
      drawStem(t,w);

      // stem tip for anchoring heads
      const stemTipX=Math.round(stemX0+stemOffsetX(stemTopY,t,w*1.1));

      // head anchors
      for(let i=0;i<heads.length;i++){
        const H=heads[i];
        const targetX=stemTipX + H.dx + w*1.1 + Math.sin(t*1.2+H.phase)*0.5;
        const targetY=(stemTopY-4) + H.dy + Math.sin(t*1.1+H.phase)*0.25;
        H.x += (targetX - H.x)*0.2; H.y += (targetY - H.y)*0.15;
      }

      // big leaves around each head (drawn before florets so they sit behind)
      for(const H of heads){ drawCollarLeaves(H.x,H.y,w); }

      // clusters (ring florets) with slight shear/flattening
      const shear=Math.max(-0.9,Math.min(0.9,w*0.10));
      for(const f of florets){
        const H=heads[f.hid];
        const rr=f.r + 0.35*Math.sin(t*0.8 + f.ph + H.phase);
        const ex=(1+shear)*rr*Math.cos(f.ang);
        const ey=(1-shear*0.35)*rr*Math.sin(f.ang);
        const fx=H.x + ex, fy=H.y + ey*0.9;
        drawFloret(fx,fy,f.sz,f.colA,f.colB,f.ph,t);
      }
    }

    function frame(now){
      const t=(now-start)/1000; paintLow(t);
      dctx.clearRect(0,0,display.width,display.height); dctx.fillStyle=P.bg0; dctx.fillRect(0,0,display.width,display.height);
      const scale=3.2, w=LOW*scale, h=LOW*scale; const x=(display.width-w)/2, y=(display.height-h)/2+36; dctx.imageSmoothingEnabled=false; dctx.drawImage(low, Math.round(x), Math.round(y), Math.round(w), Math.round(h));
      requestAnimationFrame(frame);
    }

    function resize(){
      const css=Math.min(window.innerWidth,window.innerHeight)*0.9; display.style.width=display.style.height=Math.max(340,Math.floor(css))+'px';
    }

    resize(); window.addEventListener('resize', resize); requestAnimationFrame(frame);
  </script>
</body>
</html>
